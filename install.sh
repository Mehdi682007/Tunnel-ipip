#!/bin/bash

# IPv6 sit + ipip6 Tunnel Manager üòé
# Single Iran <-> Foreign tunnel + persistent port forwarding

SERVICE_NAME="tunnel-setup.service"
SCRIPT_PATH="/usr/local/bin/tunnel-setup.sh"
CONFIG_DIR="/etc/tunnel-manager"
CONFIG_FILE="${CONFIG_DIR}/config"

# Colors & styles
BOLD="\e[1m"
RESET="\e[0m"
GREEN="\e[32m"
RED="\e[31m"
YELLOW="\e[33m"
CYAN="\e[36m"
MAGENTA="\e[35m"
GRAY="\e[90m"

CHECK="‚úÖ"
CROSS="‚ùå"
WARN="‚ö†Ô∏è"
INFO="‚ÑπÔ∏è"

require_root() {
  if [[ $EUID -ne 0 ]]; then
    echo -e "${RED}${CROSS} This script must be run as root (use sudo).${RESET}"
    exit 1
  fi
}

pause() {
  echo
  read -rp "Press Enter to return to the menu..." _
}

detect_local_ip() {
  local ip
  ip=$(ip -4 route get 1.1.1.1 2>/dev/null | awk '{for(i=1;i<=NF;i++){ if($i=="src"){print $(i+1); exit}}}')
  echo "$ip"
}

print_banner() {
  clear
  # ASCII ŸÑŸà⁄ØŸà ‚Äì ÿß⁄Øÿ± ÿ™ÿ±ŸÖ€åŸÜÿßŸÑ ⁄©Ÿà⁄Ü€å⁄© ÿ®ÿßÿ¥Ÿá ŸÅŸÇÿ∑ ŸÖŸÖ⁄©ŸÜŸá wrap ÿ®ÿ¥Ÿáÿå ŸàŸÑ€å ÿÆÿ±ÿßÿ® ŸÜŸÖ€å‚Äå⁄©ŸÜŸá
  echo -e "${MAGENTA}"
  cat << 'EOF'
 _______                                _______   __            __    __                __  __        ______  _______  ______  _______  
|       \                              |       \ |  \          |  \  |  \              |  \|  \      |      \|       \|      \|       \ 
| $$$$$$$\ ______    ______    _______ | $$$$$$$\ \$$  ______   \$$ _| $$_     ______  | $$| $$       \$$$$$$| $$$$$$$\\$$$$$$| $$$$$$$\
| $$__/ $$|      \  /      \  /       \| $$  | $$|  \ /      \ |  \|   $$ \   |      \ | $$| $$        | $$  | $$__/ $$ | $$  | $$__/ $$
| $$    $$ \$$$$$$\|  $$$$$$\|  $$$$$$$| $$  | $$| $$|  $$$$$$\| $$ \$$$$$$    \$$$$$$\| $$| $$        | $$  | $$    $$ | $$  | $$    $$
| $$$$$$$ /      $$| $$   \$$ \$$    \ | $$  | $$| $$| $$  | $$| $$  | $$ __  /      $$| $$| $$        | $$  | $$$$$$$  | $$  | $$$$$$$ 
| $$     |  $$$$$$$| $$       _\$$$$$$\| $$__/ $$| $$| $$__| $$| $$  | $$|  \|  $$$$$$$| $$| $$       _| $$_ | $$      _| $$_ | $$      
| $$      \$$    $$| $$      |       $$| $$    $$| $$ \$$    $$| $$   \$$  $$ \$$    $$| $$| $$      |   $$ \| $$     |   $$ \| $$      
 \$$       \$$$$$$$ \$$       \$$$$$$$  \$$$$$$$  \$$ _\$$$$$$$ \$$    \$$$$   \$$$$$$$ \$$ \$$       \$$$$$$ \$$      \$$$$$$ \$$      

EOF
  echo -e "${RESET}"
  echo -e "${BOLD}${CYAN}Tunnel Manager v1.0${RESET}"
  echo -e "${GRAY}YouTube: youtube.com/@PARSDIGITAL   GitHub: github.com/Mehdi682007${RESET}"
  echo
}

generate_tunnel_script() {
  # expects globals:
  # ROLE, LOCAL_IP, REMOTE_IP, FC_LOCAL, FC_REMOTE, PTP_IPV4_LOCAL, REMOTE_IPV4_TUN (for Iran), PORT_LIST

  cat > "$SCRIPT_PATH" <<EOF
#!/bin/bash
set -e

# Auto-generated by tunnel-manager.sh

# Clean any existing tunnels
ip tunnel del 6to4_PD_TUN 2>/dev/null || true
ip -6 tunnel del ip6PD_tun 2>/dev/null || true

# 1) 6to4 tunnel using public IPv4
ip tunnel add 6to4_PD_TUN mode sit remote ${REMOTE_IP} local ${LOCAL_IP}
ip -6 addr add ${FC_LOCAL}/64 dev 6to4_PD_TUN
ip link set 6to4_PD_TUN mtu 1480
ip link set 6to4_PD_TUN up

# 2) IPv6-in-IPv6 tunnel carrying IPv4 /30
ip -6 tunnel add ip6PD_tun mode ipip6 remote ${FC_REMOTE} local ${FC_LOCAL}
ip addr add ${PTP_IPV4_LOCAL} dev ip6PD_tun
ip link set ip6PD_tun mtu 1440
ip link set ip6PD_tun up
EOF

  if [[ "$ROLE" == "iran" ]]; then
    cat >> "$SCRIPT_PATH" <<EOF

# Enable IPv4 forwarding
sysctl -w net.ipv4.ip_forward=1 >/dev/null 2>&1 || true

# Base remote IPv4 inside tunnel /30
REMOTE_IPV4_TUN="${REMOTE_IPV4_TUN}"
EOF

    # initial TCP ports from install
    if [[ -n "$PORT_LIST" ]]; then
      CLEAN_PORTS=$(echo "$PORT_LIST" | tr -d '[:space:]')
      IFS=',' read -r -a PORT_ARRAY <<< "$CLEAN_PORTS"

      for PORT in "${PORT_ARRAY[@]}"; do
        if [[ "$PORT" =~ ^[0-9]+$ ]]; then
          cat >> "$SCRIPT_PATH" <<EOF

# Initial TCP port ${PORT}
if ! iptables -t nat -C PREROUTING -p tcp --dport ${PORT} -j DNAT --to-destination \${REMOTE_IPV4_TUN} -m comment --comment "tunnel-setup" 2>/dev/null; then
  iptables -t nat -A PREROUTING -p tcp --dport ${PORT} -j DNAT --to-destination \${REMOTE_IPV4_TUN} -m comment --comment "tunnel-setup"
fi
EOF
        fi
      done
    fi

    cat >> "$SCRIPT_PATH" <<'EOF'

# NAT for outgoing traffic (with comment for cleanup)
if ! iptables -t nat -C POSTROUTING -j MASQUERADE -m comment --comment "tunnel-setup" 2>/dev/null; then
  iptables -t nat -A POSTROUTING -j MASQUERADE -m comment --comment "tunnel-setup"
fi
EOF
  fi

  cat >> "$SCRIPT_PATH" <<'EOF'

exit 0
EOF

  chmod +x "$SCRIPT_PATH"
}

install_or_update_tunnel() {
  mkdir -p "$CONFIG_DIR"

  print_banner
  echo -e "${BOLD}üöÄ Install / Update tunnel${RESET}"
  echo "----------------------------"
  echo
  echo "Which server is this?"
  echo "  1) üåçüåê‚úÖ Kharej (Foreign) server"
  echo "  2) üü¢‚ö™Ô∏èüî¥ Iran server"
  read -rp "Choose your role [1-2]: " ROLE_CHOICE

  case "$ROLE_CHOICE" in
    1)
      ROLE="foreign"
      echo -e "${CHECK} Role set to: Foreign server"
      ;;
    2)
      ROLE="iran"
      echo -e "${CHECK} Role set to: Iran server"
      ;;
    *)
      echo -e "${RED}${CROSS} Invalid choice.${RESET}"
      return
      ;;
  esac

  # store ROLE for later (Add Ports)
  echo "ROLE=${ROLE}" > "$CONFIG_FILE"

  echo
  echo -e "${INFO} Detecting local public IPv4..."
  LOCAL_IP=$(detect_local_ip)

  if [[ -z "$LOCAL_IP" ]]; then
    echo -e "${WARN} Could not auto-detect local IP."
    read -rp "Please enter this server's public IPv4: " LOCAL_IP
  else
    echo -e "${CHECK} Auto-detected local IP: ${LOCAL_IP}"
    read -rp "Press Enter if this is correct, or type another IPv4: " LOCAL_IP_OVERRIDE
    if [[ -n "$LOCAL_IP_OVERRIDE" ]]; then
      LOCAL_IP="$LOCAL_IP_OVERRIDE"
    fi
  fi

  if [[ -z "$LOCAL_IP" ]]; then
    echo -e "${RED}${CROSS} Local IP cannot be empty.${RESET}"
    return
  fi

  echo
  read -rp "Enter the public IPv4 of the opposite server: " REMOTE_IP
  if [[ -z "$REMOTE_IP" ]]; then
    echo -e "${RED}${CROSS} Remote IP cannot be empty.${RESET}"
    return
  fi

  # role-based addressing
  if [[ "$ROLE" == "foreign" ]]; then
    FC_LOCAL="fc00::1"
    FC_REMOTE="fc00::2"
    PTP_IPV4_LOCAL="192.168.13.1/30"
    REMOTE_IPV4_TUN="192.168.13.2"
  else
    FC_LOCAL="fc00::2"
    FC_REMOTE="fc00::1"
    PTP_IPV4_LOCAL="192.168.13.2/30"
    REMOTE_IPV4_TUN="192.168.13.1"
  fi

  PORT_LIST=""
  if [[ "$ROLE" == "iran" ]]; then
    echo
    echo -e "${INFO} Port forwarding on Iran server:"
    echo "  - IPv4 tunnel internal remote: ${REMOTE_IPV4_TUN}"
    echo "  - You can forward TCP ports (e.g. 443,8080,2096)"
    read -rp "Enter initial TCP ports to forward (empty for none): " PORT_LIST
  fi

  echo
  echo -e "${INFO} Generating tunnel script at ${SCRIPT_PATH} ..."
  generate_tunnel_script

  echo -e "${CHECK} Tunnel script created."

  echo
  echo -e "${INFO} Creating systemd service at /etc/systemd/system/${SERVICE_NAME} ..."

  cat > "/etc/systemd/system/${SERVICE_NAME}" <<EOF
[Unit]
Description=Setup Network Tunnel (IPv6 sit + ipip6)
After=network.target

[Service]
Type=oneshot
ExecStart=${SCRIPT_PATH}
RemainAfterExit=yes
Restart=on-failure
RestartSec=5s

[Install]
WantedBy=multi-user.target
EOF

  echo -e "${CHECK} Systemd service file created."

  echo
  echo -e "${INFO} Reloading systemd, enabling and starting the service..."
  systemctl daemon-reload
  systemctl enable "$SERVICE_NAME" >/dev/null 2>&1 || true
  systemctl start "$SERVICE_NAME" || true

  echo
  echo -e "${CHECK} Installation / update completed."
  echo
  systemctl --no-pager status "$SERVICE_NAME" || true

  echo
  read -rp "Do you want to reboot the server now? [y/N]: " REBOOT_ANSWER
  case "$REBOOT_ANSWER" in
    y|Y|yes|YES)
      echo -e "${YELLOW}üîÅ Rebooting server...${RESET}"
      reboot
      ;;
    *)
      echo -e "${INFO} No reboot requested. Tunnel will be restored on next boot.${RESET}"
      ;;
  esac
}

status_tunnel() {
  print_banner
  echo -e "${BOLD}üß™ Tunnel status${RESET}"
  echo "-----------------"
  echo

  if systemctl list-unit-files | grep -q "^${SERVICE_NAME}"; then
    state=$(systemctl is-active "$SERVICE_NAME" 2>/dev/null || echo "unknown")
    enabled=$(systemctl is-enabled "$SERVICE_NAME" 2>/dev/null || echo "disabled")

    if [[ "$state" == "active" ]]; then
      echo -e "Service: ${GREEN}ACTIVE${RESET} (${enabled}) ${CHECK}"
    else
      echo -e "Service: ${RED}${state^^}${RESET} (${enabled}) ${CROSS}"
    fi
  else
    echo -e "${RED}${CROSS} Service ${SERVICE_NAME} is not installed.${RESET}"
  fi

  echo
  echo "ip tunnel show 6to4_PD_TUN:"
  ip tunnel show 6to4_PD_TUN 2>/dev/null || echo "  (not found)"

  echo
  echo "ip -6 tunnel show ip6PD_tun:"
  ip -6 tunnel show ip6PD_tun 2>/dev/null || echo "  (not found)"

  echo
  echo "NAT rules with comment \"tunnel-setup\":"
  if command -v iptables-save >/dev/null 2>&1; then
    iptables-save | grep "tunnel-setup" || echo "  (no matching rules)"
  else
    echo "  iptables-save not available."
  fi

  pause
}

add_ports_menu() {
  print_banner
  echo -e "${BOLD}‚ûï Add TCP ports (Iran server only)${RESET}"
  echo "-------------------------------------"
  echo

  if [[ ! -f "$CONFIG_FILE" ]]; then
    echo -e "${RED}${CROSS} No config file found. Please run Install/Update first.${RESET}"
    pause
    return
  fi

  # shellcheck disable=SC1090
  source "$CONFIG_FILE"

  if [[ "$ROLE" != "iran" ]]; then
    echo -e "${RED}${CROSS} This option is only valid on the Iran server.${RESET}"
    pause
    return
  fi

  if ! command -v iptables-save >/dev/null 2>&1; then
    echo -e "${RED}${CROSS} iptables-save is not available on this system.${RESET}"
    pause
    return
  fi

  REMOTE_IPV4_TUN="192.168.13.1"

  echo "Tunnel internal remote IPv4: ${REMOTE_IPV4_TUN}"
  echo
  echo "Enter additional TCP ports to forward."
  echo "Example: 443,8080,2096"
  read -rp "TCP ports: " NEW_PORTS

  if [[ -z "$NEW_PORTS" ]]; then
    echo -e "${WARN} No ports entered. Nothing to do.${RESET}"
    pause
    return
  fi

  CLEAN_PORTS=$(echo "$NEW_PORTS" | tr -d '[:space:]')
  IFS=',' read -r -a PORT_ARRAY <<< "$CLEAN_PORTS"

  if [[ ! -f "$SCRIPT_PATH" ]]; then
    echo -e "${RED}${CROSS} ${SCRIPT_PATH} not found. Please reinstall the tunnel first.${RESET}"
    pause
    return
  fi

  echo
  for PORT in "${PORT_ARRAY[@]}"; do
    if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
      echo -e "${RED}${CROSS} Skipping invalid port: ${PORT}${RESET}"
      continue
    fi

    # check duplicate in existing tunnel rules
    if iptables-save | grep -q "tunnel-setup" | grep -q -- "--dport ${PORT}"; then
      echo -e "${RED}${CROSS} Port ${PORT} is already used in an existing tunnel rule. Skipping.${RESET}"
      continue
    fi

    echo -e "${INFO} Adding DNAT rule for TCP port ${PORT} -> ${REMOTE_IPV4_TUN}"

    if iptables -t nat -A PREROUTING -p tcp --dport "${PORT}" -j DNAT --to-destination "${REMOTE_IPV4_TUN}" -m comment --comment "tunnel-setup" 2>/dev/null; then
      echo -e "${GREEN}${CHECK} Runtime rule added for port ${PORT}.${RESET}"

      # append persistent rule to tunnel-setup.sh
      cat >> "$SCRIPT_PATH" <<EOF

# Added later: TCP port ${PORT}
if ! iptables -t nat -C PREROUTING -p tcp --dport ${PORT} -j DNAT --to-destination ${REMOTE_IPV4_TUN} -m comment --comment "tunnel-setup" 2>/dev/null; then
  iptables -t nat -A PREROUTING -p tcp --dport ${PORT} -j DNAT --to-destination ${REMOTE_IPV4_TUN} -m comment --comment "tunnel-setup"
fi
EOF

      echo -e "${GREEN}${CHECK} Persistent rule appended to ${SCRIPT_PATH}.${RESET}"
    else
      echo -e "${RED}${CROSS} Failed to add runtime rule for port ${PORT}.${RESET}"
    fi
  done

  echo
  echo -e "${CHECK} Finished processing requested ports.${RESET}"
  pause
}

uninstall_tunnel() {
  print_banner
  echo -e "${BOLD}üßπ Uninstall tunnel${RESET}"
  echo "---------------------"
  echo
  read -rp "Are you sure you want to remove the tunnel and service? [y/N]: " CONFIRM
  case "$CONFIRM" in
    y|Y|yes|YES)
      ;;
    *)
      echo -e "${INFO} Uninstall cancelled.${RESET}"
      pause
      return
      ;;
  esac

  echo
  echo -e "${INFO} Stopping and disabling service (if exists)..."
  systemctl stop "$SERVICE_NAME" 2>/dev/null || true
  systemctl disable "$SERVICE_NAME" 2>/dev/null || true
  rm -f "/etc/systemd/system/${SERVICE_NAME}"
  systemctl daemon-reload || true
  echo -e "${CHECK} Service removed."

  echo
  echo -e "${INFO} Deleting tunnels (if exist)..."
  ip tunnel del 6to4_PD_TUN 2>/dev/null || true
  ip -6 tunnel del ip6PD_tun 2>/dev/null || true
  echo -e "${CHECK} Tunnel devices cleaned."

  echo
  echo -e "${INFO} Removing iptables rules with comment \"tunnel-setup\"..."
  if command -v iptables-save >/dev/null 2>&1; then
    iptables-save | awk '
      /^#/ {next}
      /^\*/ {table = substr($1,2); next}
      /^COMMIT/ {next}
      /tunnel-setup/ {
        gsub("^-A","-D");
        print table " " $0
      }
    ' | while read -r table rule; do
      iptables -t "$table" $rule 2>/dev/null || true
    done
    echo -e "${CHECK} iptables rules cleaned (where tagged)."
  else
    echo -e "${WARN} iptables-save not available, cannot auto-clean rules.${RESET}"
  fi

  echo
  echo -e "${INFO} Removing script and config..."
  rm -f "$SCRIPT_PATH" "$CONFIG_FILE" 2>/dev/null || true

  echo
  echo -e "${GREEN}${CHECK} Tunnel fully uninstalled.${RESET}"
  pause
}

print_menu() {
  echo "====================================="
  echo "  üåê IPv6 Tunnel Manager (sit+ipip6)"
  echo "====================================="
  echo "  1) üöÄ Install / Update tunnel"
  echo "  2) üß™ Show tunnel status"
  echo "  3) ‚ûï Add TCP ports (Iran only)"
  echo "  4) üßπ Uninstall tunnel"
  echo "  5) ‚ùå Exit"
  echo
}

main_menu() {
  while true; do
    print_banner
    print_menu
    read -rp "Your choice [1-5]: " CHOICE

    case "$CHOICE" in
      1) install_or_update_tunnel ;;
      2) status_tunnel ;;
      3) add_ports_menu ;;
      4) uninstall_tunnel ;;
      5)
        echo
        echo -e "${CHECK} Goodbye! üëã${RESET}"
        exit 0
        ;;
      *)
        echo -e "${RED}${CROSS} Invalid choice. Please use 1-5.${RESET}"
        sleep 1.5
        ;;
    esac
  done
}

# entrypoint
require_root
main_menu
